module tiger

imports ds-signatures/Tiger-sig
imports dynamics/store

signature
   
  arrows
    Module -init-> V
    E |- Exp :: H --> V :: H
    E |- (List(FArg) * List(Exp)) :: H --> Env :: H
    E |- LValue :: H -lval-> Address :: H
    E |- Dec :: H --> Env :: H
    E |- List(Dec) :: H --> Env :: H
    E |- List(FunDec) :: H -env-> Env :: H
    E |- List(FunDec) :: H --> V :: H
    
    // desugar(Exp) --> Exp

  native operators
    parseI  : String -> Int
    printI  : Int -> String
    addI    : Int * Int -> Int
    subI    : Int * Int -> Int
    mulI    : Int * Int -> Int
    divI    : Int * Int -> Int
    ltI     : Int * Int -> Int
    leqI    : Int * Int -> Int
    eqI     : Int * Int -> Int
    concatS : String * String -> String

rules

  Mod(e) -init-> v
  where 
    E {} |- e :: H {} --> v.

rules // bindings
    
  Var(x) -lval-> lookup(x).
  
  lv : LValue --> read(lv).
  
  Assign(lv, e) --> write(lv, e). 
  
  Let(E, es) --> v
  where E |- Seq(es) --> v.
  
  [E | decs] : List(Dec) --> E'
  where E |- decs --> E'.
  
rules // variable declarations

  VarDec(x, _, v) --> allocateVar(x, v).
  
  VarDecNoInit(x, _) --> allocateVar(x, UndefV()). 
  
rules // type declarations

  E |- TypeDecs(_) --> E.
  
rules // functions

  FunDecs(fds) --> E
  where fds -env-> E; E |- fds --> _.
  
  E |- [] : List(FunDec) -env-> E.  
  
  [FunDec(f, _, _, _) | fds] : List(FunDec) -env-> E
  where 
    E allocateVar(f, UndefV()) |- fds -env-> E.
  
  [] : List(FunDec) --> UnitV().
  
  E |- [FunDec(f, args, _, e) | fds] : List(FunDec) --> v
  where 
    writeVar(f, ClosureV(args, e, E)) --> _; fds --> v.
  
  Call(Var(f), es) --> v
  where
    readVar(f) --> ClosureV(args, e, E);
    (args, es) --> E';
    E {E', E} |- e --> v.
    
  ([], []) : (List(FArg) * List(Exp)) --> {}.
    
  ([FArg(x, _) | args], [v | es]) : (List(FArg) * List(Exp)) --> {x |--> a, E}
  where allocate(v) --> a; (args, es) --> E.
  
    
rules // control-flow
    
  IfThen(IntV(i), e) --> v
  where
    case i of {
      0 => 
        UnitV() => v
      otherwise => 
        e --> v
    }.
  
  If(IntV(i), e1, e2) --> v
  where
    case i of {
      0 => 
        e2 --> v
      otherwise => 
        e1 --> v
    }.
    
  While(e1, e2) --> IfThen(e1, Seq([e1, While(e1, e2)])).
    
//  e@For(_, _, _, _) --> desugar(e).
  
//  desugar(For(Var(x), e1, e2, e3)) -->
//    Let([VarDec(x, NoTp(), e1),
//         VarDec(end, NoTp(), e2)], 
//        [While(Lt(Var(x), Var(end)), Seq([
//           e3,
//           Assign(Var(x), Plus(Var(x), Int("1")))
//         ]))])
//  where printI(fresh) : Id => end.  // capture?
//
  For(Var(x), e1, e2, e3) -->
    Let([VarDec(x, NoTp(), e1),
         VarDec(end, NoTp(), e2)], 
        [While(Lt(Var(x), Var(end)), Seq([
           e3,
           Assign(Var(x), Plus(Var(x), Int("1")))
         ]))])
  where printI(fresh) : Id => end.  // capture?  
 
  Seq([]) --> UnitV().
  
  Seq([v]) --> v.
  
  Seq([_ : V | es@[_|_]]) --> Seq(es).
  
  // Assign(e1, e2) --> 
      
rules // literals

  Int(i) --> IntV(parseI(i)).

rules // operators

  Uminus(e) --> Minus(Int("0"), e).
     
  Plus(IntV(i), IntV(j)) --> IntV(addI(i, j)).  
     
  Minus(IntV(i), IntV(j)) --> IntV(subI(i, j)).  
     
  Times(IntV(i), IntV(j)) --> IntV(mulI(i, j)). 
     
  Divide(IntV(i), IntV(j)) --> IntV(divI(i, j)).
     
  Eq(IntV(i), IntV(j)) --> IntV(eqI(i, j)).
  
  Lt(IntV(i), IntV(j)) --> IntV(ltI(i, j)).
  
  Leq(IntV(i), IntV(j)) --> IntV(leqI(i, j)).
  
  Gt(e1, e2) --> Lt(e2, e1).
  
  Geq(e1, e2) --> Leq(e2, e1).
  
  Neq(e1, e2) --> If(Eq(e1, e2), Int("0"), Int("1")).
  
  And(e1, e2) --> If(e1, e2, Int("0")).
  
  Or(e1, e2) --> If(e1, Int("1"), e2).
  
  
