module operators

imports ds-signatures/Tiger-sig
imports dynamics/natives
imports dynamics/store

signature
  arrows
    E |- Exp :: H --> V :: H
    
    List(InitField) --> Env
    
    initArray(Int, Int, V) --> Unit

rules // literals

  Int(i) --> IntV(parseI(i)).
  
  String(s) --> StringV(s). 
  
  NilExp() --> NilV(). 
  
  Record(_, fields) --> RecordV(E)  
  where fields --> E.
  
  [] : List(InitField) --> {}.
  
  [InitField(f, v) | fields] : List(InitField) --> {f |--> a, E}
  where
    allocate(v) --> a; fields --> E.
  
  Array(_, IntV(i), v) --> ArrayV(H)
  where
    initArray(0, i, v) :: H {} --> _ :: H.
  
  // initArray
  
rules // operators

  Uminus(e) --> Minus(Int("0"), e).
     
  Plus(IntV(i), IntV(j)) --> IntV(addI(i, j)).  
     
  Minus(IntV(i), IntV(j)) --> IntV(subI(i, j)).  
     
  Times(IntV(i), IntV(j)) --> IntV(mulI(i, j)). 
     
  Divide(IntV(i), IntV(j)) --> IntV(divI(i, j)).
     
  Eq(IntV(i), IntV(j)) --> IntV(eqI(i, j)).
  
  Lt(IntV(i), IntV(j)) --> IntV(ltI(i, j)).
  
  Leq(IntV(i), IntV(j)) --> IntV(leqI(i, j)).
  
  Gt(e1, e2) --> Lt(e2, e1).
  
  Geq(e1, e2) --> Leq(e2, e1).
  
  Neq(e1, e2) --> If(Eq(e1, e2), Int("0"), Int("1")).
  
  And(e1, e2) --> If(e1, e2, Int("0")).
  
  Or(e1, e2) --> If(e1, Int("1"), e2).
